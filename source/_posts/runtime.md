---
title: 设计模式
date: 2018-01-11 17:47:44
tags:
  - 设计模式
categories:
  - Git
author: 奎宇

---
##  设计原则

### 单一职责原则: 
**一个类只承担一个职责**
### 开闭原则: 
**对软件实体的改动，最好用扩展而非修改的方式**。类、模块、函数可以扩展，不要去修改。
### 里氏替换原则: 
父类的功能都可以用子类替代，不会影响。子类可以扩展父类方法，不要复写父类的方法
### 接口隔离原则: 
接口中含有不必要的方法，拆分成更小和更具体接口。
### 依赖倒置原则：
高层模块，低层模块，细节都应该依赖抽象
* 模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过接口或抽象类产生的。
* 接口或抽象类不依赖实现类
* 实现类依赖接口或抽象类

项目中使用

* 每个类尽量都有接口或者抽象类，或者抽象类和接口两都具备
* 变量的表面类型尽量是接口或者抽象类
任何类都不应该从具体类派生
尽量不要覆写基类的方法 
* 如果基类是一个抽象类，而这个方法已经实现了，子类尽量不要覆写。类间依赖的是抽象，覆写了抽象方法，对依赖的稳定性会有一定的影响。
* 结合里氏替换原则使用 
里氏替换原则：父类出现的地方子类就能出现。结合本章我们得出了一个通俗的规则：接口负责定义public属性和方法，并且声明与其他对象的依赖关系。抽象类负责公共构造部分的实现，实现类准确的实现业务逻辑，同时在适当的时候对父类进行细化。

### 迪米特法则
一个对象应该对其他对象保持最少了解， 就是一个类对自己依赖的类知道的越少越好，也就是对于被依赖的类，向外公开的方法应该尽可能的少。

* 从被依赖者的角度来说：只暴露应该暴露的方法或者属性，即在编写相关的类的时候确定方法/属性的权限
* 从依赖者的角度来说，只依赖应该依赖的对象

### 组合/聚合服用模式

在一个新的对象里面使用一些已有的对象，使之成为新对象的一部分；新的对象通过向这些对象的委派达到复用已有功能的目的。它的设计原则是：要尽量使用合成/聚合，尽量不要使用继承。

## 设计模式

### 创造性模式

 
> **处理对象创建的设计模式**

两个主导思想

* 系统使用的具体类封装起来
* 隐藏具体类的实例创建和结合的方式

#### 工厂模式（Factory Pattern）

> 定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method 使一个类的实例化延迟到其子类。

* 当一个类不知道它所必须创建的对象的类的时候。
* 当一个类希望由它的子类来指定它所创建的对象的时候。
* 当类将创建对象的职责委托给多个帮助子类中的某一个，并且你希望将哪一个帮助子类是代理者这一信息局部化的时候。


#### 抽象工厂模式（Abstract Factory Pattern）

> 提供一个接口，用于创建与某些对象相关或依赖于某些对象的类家族，而又不需要指定它们的具体类。
> 通过这种模式可以去除客户代码和来自工厂的具体对象细节之间的耦合关系。

提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。


* 一个系统要独立于它的产品的创建、组合和表示时。
* 一个系统要由多个产品系列中的一个来配置时。
* 当你要强调一系列相关的产品对象的设计以便进行联合使用时。
* 当你提供一个产品类库，而只想显示它们的接口而不是实现时。

#### 建造者模式（Builder Pattern）
> 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示

* 当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时。

* 当构造过程必须允许被构造的对象有不同的表示时。

#### 原型模式（Prototype Pattern）
允许一个对象再创建另外一个可定制的对象，根本无需知道任何如何创建的细节

使用原型实例指定创建对象的种类，并通过复制这个原型创建新的对象。也就是提供一个快速复制对象的快捷方式

**深复制，复制的是对象**

#### 单例模式（Singleton Pattern）


保证一个类仅有一个实例，并提供一个访问它的全局访问点

在只能有一个实例而且客户可以从一个众所周知的访问点访问它时。

### 结构型模式

**处理类或对象的组合**

#### 适配器模式 [（Adapter Pattern）](http://www.cnblogs.com/java-my-life/archive/2012/04/13/2442795.html)

适配器模式把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起工作的两个类能够在一起工作。

##### 类的适配器模式
类的适配器模式把适配的类的API转换成为目标类的API
##### 对象的适配器模式
　　与类的适配器模式一样，对象的适配器模式把被适配的类的API转换成为目标类的API，与类的适配器模式不同的是，对象的适配器模式不是使用继承关系连接到Adaptee类，而是使用委派关系连接到Adaptee类。
  ##### 接口的适配器模式
  一个接口中有多个抽象方法。（java）必须实现该接口的所有方法。借助于一个抽象类，该抽象类实现了该接口，实现了所有的方法，只和该抽象类取得联系，继承该抽象类，重写我们需要的方法就行
  
  #### 桥接模式[（Bridge Pattern）](https://www.cnblogs.com/chenssy/p/3317866.html)
  
>  桥接模式即将抽象部分与它的实现部分分离开来，使他们都可以独立变化。
>  桥接模式将继承关系转化成关联关系，它降低了类与类之间的耦合度，减少了系统中类的数量，也减少了代码量。


** 实现系统可能有多个角度分类，每一种角度都可能变化，那么把这种多角度分类给分离出来让他们独立变化，减少他们之间耦合 **

#### 组合模式（Composite Pattern）

将对象组合成树形结构以表示“部分整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。

#### 装饰模式（Decorator Pattern）

这种模式动态地将额外的责任附加到一个对象上。在进行功能扩展时，装饰是子类化之外的一种灵活的备选方法。和子类化一样，采纳装饰模式可以加入新的行为，而又不必修改已有的代码。装饰将需要扩展的类的对象进行包装，实现与该对象相同的接口，并在将任务传递给被包装对象之前或之后加入自己的行为。装饰模式表达了这样的设计原则：类应该接纳扩展，但避免修改

ios Category

#### 外观模式（Facade Pattern）

这种模式为子系统中的一组接口提供统一的接口。表观模式定义一个更高级别的接口，通过减少复杂度和隐藏子系统之间的通讯和依赖性，使子系统更加易于使用。


#### 过滤器模式（Filter、Criteria Pattern）

过滤器模式（Filter Pattern）或标准模式（Criteria Pattern）是一种设计模式，这种模式允许开发人员使用不同的标准来过滤一组对象，通过逻辑运算以解耦的方式把它们连接起来。这种类型的设计模式属于结构型模式，它结合多个标准来获得单一标准。


#### 享元模式（Flyweight Pattern）

享元模式的主要目的是实现对象的共享，即共享池，当系统中对象多的时候可以减少内存的开销，通常与工厂模式一起使用。

适合用享元模式来处理，建一个工厂类，将类似属性作为内部数据，其它的作为外部数据，在方法调用时，当做参数传进来，这样就节省了空间，减少了实例的数量。




#### 代理模式（Proxy Pattern）

多一个代理类出来，替原对象进行一些操作

如果已有的方法在使用的时候需要对原有的方法进行改进，此时有两种办法：

1、修改原有的方法来适应。这样违反了“对扩展开放，对修改关闭”的原则。

2、就是采用一个代理类调用原有的方法，且对产生的结果进行控制。这种方法就是代理模式。

### 行为型模式

#### 责任链模式（Chain of Responsibility Pattern）

请求创建了一个接收者对象的链。这种模式给予请求的类型，对请求的发送者和接收者进行解耦。这种类型的设计模式属于行为型模式。

通常每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推。

#### 命令模式（Command Pattern）

将一个请求封装成一个对象，从而让你使用不同的请求把客户端参数化，对请 求排队或者记录请求日志，可以提供命令的撤销和恢复功能。

三个角色：

* Receiver接受者角色：该角色就是干活的角色，命令传递到这里是应该被执行的
* Command命令角色：需要执行的所有命令都在这里声明
* Invoker调用者角色：接收到命令，并执行命令

#### 解释器模式（Interpreter Pattern）

给定一个语言，定义它的文法表示，并定义一个解释器，这个解释器使用该标识来解释语言中的句子。

三种对象：

- 语言，即你输入的或者说需要翻译的部分是什么
- 文法，即你用什么方式、方法翻译改语言。
- 解释器对象，即该对象包括了多种文法，只需调用该对象进行解释

> 常见的树的先序遍历、中序遍历、层次遍历、后序遍历等都可以用解释器模式实现。

#### 迭代器模式（Iterator Pattern）

迭代器提供了一种顺序访问集合对象中元素的方法，而无需暴漏结构的底层表示和细节。遍历集合中元素的职能从集合本身转移到迭代器对象。迭代器定义了一个用于访问集合元素并记录当前元素的接口。不同的迭代器可以执行不同的策略。

#### 中介者模式（Mediator Pattern）
用一个对象来封装一组或者一系列对象的交互方式，使对象间的交互可以在一个中介者对象中处理，从而使各对象耦合松散，而且可以独立的改变它们之间的交互。中介者就好比站在十字路口的交通警察，如果改变十字路口的交通模式，只需要把新的交通策略给交通警察即可，而不是路上的所有车辆，这样才能更好的协调来自不同方向车辆。



#### 备忘录模式（Memento Pattern）

在不破坏封闭的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。


- Originator(发起人)：负责创建一个备忘录Memento，用以记录当前时刻自身的内部状态，并可使用备忘录恢复内部状态。
  Originator可以根据需要决定Memento存储自己的哪些内部状态。
- Memento(备忘录)：负责存储Originator对象的内部状态，并可以防止Originator以外的其他对象访问备忘录。
  备忘录有两个接口：Caretaker只能看到备忘录的窄接口，他只能将备忘录传递给其他对象。
  Originator却可看到备忘录的宽接口，允许它访问返回到先前状态所需要的所有数据。
- Caretaker(管理者):负责备忘录Memento，不能对Memento的内容进行访问或者操作。

#### 观察者模式（Observer Pattern）
#### 状态模式（State Pattern）
#### 空对象模式（Null Object Pattern）
#### 策略模式（Strategy Pattern）
#### 模板模式（Template Pattern）
#### 访问者模式（Visitor Pattern）



